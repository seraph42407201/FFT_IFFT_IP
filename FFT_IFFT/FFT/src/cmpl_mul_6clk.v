// megafunction wizard: %ALTMULT_COMPLEX%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altmult_complex 

// ============================================================
// File Name: cmpl_mul_6clk.v
// Megafunction Name(s):
// 			altmult_complex
//
// Simulation Library Files(s):
// 			altera_mf
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 9.1 Build 222 10/21/2009 SJ Full Version
// ************************************************************


//Copyright (C) 1991-2009 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


//altmult_complex CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" IMPLEMENTATION_STYLE="AUTO" PIPELINE=6 REPRESENTATION_A="SIGNED" REPRESENTATION_B="SIGNED" WIDTH_A=18 WIDTH_B=18 WIDTH_RESULT=36 clock dataa_imag dataa_real datab_imag datab_real result_imag result_real
//VERSION_BEGIN 9.1 cbx_alt_ded_mult_y 2009:10:21:21:22:16:SJ cbx_altmult_add 2009:10:21:21:22:16:SJ cbx_altmult_complex 2009:10:21:21:22:16:SJ cbx_cycloneii 2009:10:21:21:22:16:SJ cbx_lpm_add_sub 2009:10:21:21:22:16:SJ cbx_lpm_compare 2009:10:21:21:22:16:SJ cbx_lpm_mult 2009:10:21:21:22:16:SJ cbx_mgl 2009:10:21:21:37:49:SJ cbx_padd 2009:10:21:21:22:16:SJ cbx_parallel_add 2009:10:21:21:22:16:SJ cbx_stratix 2009:10:21:21:22:16:SJ cbx_stratixii 2009:10:21:21:22:16:SJ cbx_util_mgl 2009:10:21:21:22:16:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = altmult_add 2 reg 216 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  cmpl_mul_altmult_complex_78p
	( 
	clock,
	dataa_imag,
	dataa_real,
	datab_imag,
	datab_real,
	result_imag,
	result_real) ;
	input   clock;
	input   [17:0]  dataa_imag;
	input   [17:0]  dataa_real;
	input   [17:0]  datab_imag;
	input   [17:0]  datab_real;
	output   [35:0]  result_imag;
	output   [35:0]  result_real;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   clock;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [35:0]   wire_mult_add1_result;
	wire  [35:0]   wire_mult_add2_result;
	reg	[35:0]	result_imag0c;
	reg	[35:0]	result_imag1c;
	reg	[35:0]	result_imag2c;
	reg	[35:0]	result_real0c;
	reg	[35:0]	result_real1c;
	reg	[35:0]	result_real2c;
	wire aclr;
	wire ena;
	wire  [35:0]  mult_add1_inputa;
	wire  [35:0]  mult_add1_inputb;
	wire  [35:0]  mult_add2_inputb;

	altmult_add   mult_add1
	( 
	.aclr0(aclr),
	.chainout_sat_overflow(),
	.clock0(clock),
	.dataa(mult_add1_inputa),
	.datab(mult_add1_inputb),
	.ena0(ena),
	.mult0_is_saturated(),
	.mult1_is_saturated(),
	.mult2_is_saturated(),
	.mult3_is_saturated(),
	.overflow(),
	.result(wire_mult_add1_result),
	.scanouta(),
	.scanoutb()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.accum_sload(1'b0),
	.aclr1(1'b0),
	.aclr2(1'b0),
	.aclr3(1'b0),
	.addnsub1(1'b1),
	.addnsub1_round(1'b0),
	.addnsub3(1'b1),
	.addnsub3_round(1'b0),
	.chainin({1{1'b0}}),
	.chainout_round(1'b0),
	.chainout_saturate(1'b0),
	.clock1(1'b1),
	.clock2(1'b1),
	.clock3(1'b1),
	.ena1(1'b1),
	.ena2(1'b1),
	.ena3(1'b1),
	.mult01_round(1'b0),
	.mult01_saturation(1'b0),
	.mult23_round(1'b0),
	.mult23_saturation(1'b0),
	.output_round(1'b0),
	.output_saturate(1'b0),
	.rotate(1'b0),
	.scanina({18{1'b0}}),
	.scaninb({18{1'b0}}),
	.shift_right(1'b0),
	.signa(1'b0),
	.signb(1'b0),
	.sourcea({2{1'b0}}),
	.sourceb({2{1'b0}}),
	.zero_chainout(1'b0),
	.zero_loopback(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		mult_add1.input_aclr_a0 = "ACLR0",
		mult_add1.input_aclr_a1 = "ACLR0",
		mult_add1.input_aclr_b0 = "ACLR0",
		mult_add1.input_aclr_b1 = "ACLR0",
		mult_add1.input_register_a0 = "CLOCK0",
		mult_add1.input_register_a1 = "CLOCK0",
		mult_add1.input_register_b0 = "CLOCK0",
		mult_add1.input_register_b1 = "CLOCK0",
		mult_add1.multiplier1_direction = "SUB",
		mult_add1.multiplier_aclr0 = "ACLR0",
		mult_add1.multiplier_aclr1 = "ACLR0",
		mult_add1.multiplier_register0 = "CLOCK0",
		mult_add1.multiplier_register1 = "CLOCK0",
		mult_add1.number_of_multipliers = 2,
		mult_add1.output_aclr = "ACLR0",
		mult_add1.output_register = "CLOCK0",
		mult_add1.port_addnsub1 = "PORT_UNUSED",
		mult_add1.port_signa = "PORT_UNUSED",
		mult_add1.port_signb = "PORT_UNUSED",
		mult_add1.representation_a = "SIGNED",
		mult_add1.representation_b = "SIGNED",
		mult_add1.width_a = 18,
		mult_add1.width_b = 18,
		mult_add1.width_result = 36,
		mult_add1.lpm_type = "altmult_add";
	altmult_add   mult_add2
	( 
	.aclr0(aclr),
	.chainout_sat_overflow(),
	.clock0(clock),
	.dataa(mult_add1_inputa),
	.datab(mult_add2_inputb),
	.ena0(ena),
	.mult0_is_saturated(),
	.mult1_is_saturated(),
	.mult2_is_saturated(),
	.mult3_is_saturated(),
	.overflow(),
	.result(wire_mult_add2_result),
	.scanouta(),
	.scanoutb()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.accum_sload(1'b0),
	.aclr1(1'b0),
	.aclr2(1'b0),
	.aclr3(1'b0),
	.addnsub1(1'b1),
	.addnsub1_round(1'b0),
	.addnsub3(1'b1),
	.addnsub3_round(1'b0),
	.chainin({1{1'b0}}),
	.chainout_round(1'b0),
	.chainout_saturate(1'b0),
	.clock1(1'b1),
	.clock2(1'b1),
	.clock3(1'b1),
	.ena1(1'b1),
	.ena2(1'b1),
	.ena3(1'b1),
	.mult01_round(1'b0),
	.mult01_saturation(1'b0),
	.mult23_round(1'b0),
	.mult23_saturation(1'b0),
	.output_round(1'b0),
	.output_saturate(1'b0),
	.rotate(1'b0),
	.scanina({18{1'b0}}),
	.scaninb({18{1'b0}}),
	.shift_right(1'b0),
	.signa(1'b0),
	.signb(1'b0),
	.sourcea({2{1'b0}}),
	.sourceb({2{1'b0}}),
	.zero_chainout(1'b0),
	.zero_loopback(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		mult_add2.input_aclr_a0 = "ACLR0",
		mult_add2.input_aclr_a1 = "ACLR0",
		mult_add2.input_aclr_b0 = "ACLR0",
		mult_add2.input_aclr_b1 = "ACLR0",
		mult_add2.input_register_a0 = "CLOCK0",
		mult_add2.input_register_a1 = "CLOCK0",
		mult_add2.input_register_b0 = "CLOCK0",
		mult_add2.input_register_b1 = "CLOCK0",
		mult_add2.multiplier1_direction = "ADD",
		mult_add2.multiplier_aclr0 = "ACLR0",
		mult_add2.multiplier_aclr1 = "ACLR0",
		mult_add2.multiplier_register0 = "CLOCK0",
		mult_add2.multiplier_register1 = "CLOCK0",
		mult_add2.number_of_multipliers = 2,
		mult_add2.output_aclr = "ACLR0",
		mult_add2.output_register = "CLOCK0",
		mult_add2.port_addnsub1 = "PORT_UNUSED",
		mult_add2.port_signa = "PORT_UNUSED",
		mult_add2.port_signb = "PORT_UNUSED",
		mult_add2.representation_a = "SIGNED",
		mult_add2.representation_b = "SIGNED",
		mult_add2.width_a = 18,
		mult_add2.width_b = 18,
		mult_add2.width_result = 36,
		mult_add2.lpm_type = "altmult_add";
	// synopsys translate_off
	initial
		result_imag0c = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_imag0c <= 36'b0;
		else if  (ena == 1'b1)   result_imag0c <= wire_mult_add2_result;
	// synopsys translate_off
	initial
		result_imag1c = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_imag1c <= 36'b0;
		else if  (ena == 1'b1)   result_imag1c <= result_imag0c;
	// synopsys translate_off
	initial
		result_imag2c = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_imag2c <= 36'b0;
		else if  (ena == 1'b1)   result_imag2c <= result_imag1c;
	// synopsys translate_off
	initial
		result_real0c = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_real0c <= 36'b0;
		else if  (ena == 1'b1)   result_real0c <= wire_mult_add1_result;
	// synopsys translate_off
	initial
		result_real1c = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_real1c <= 36'b0;
		else if  (ena == 1'b1)   result_real1c <= result_real0c;
	// synopsys translate_off
	initial
		result_real2c = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_real2c <= 36'b0;
		else if  (ena == 1'b1)   result_real2c <= result_real1c;
	assign
		aclr = 1'b0,
		ena = 1'b1,
		mult_add1_inputa = {dataa_imag[17:0], dataa_real[17:0]},
		mult_add1_inputb = {datab_imag[17:0], datab_real[17:0]},
		mult_add2_inputb = {datab_real[17:0], datab_imag[17:0]},
		result_imag = result_imag2c,
		result_real = result_real2c;
endmodule //cmpl_mul_altmult_complex_78p
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module cmpl_mul_6clk (
	clock,
	dataa_imag,
	dataa_real,
	datab_imag,
	datab_real,
	result_imag,
	result_real);

	input	  clock;
	input	[17:0]  dataa_imag;
	input	[17:0]  dataa_real;
	input	[17:0]  datab_imag;
	input	[17:0]  datab_real;
	output	[35:0]  result_imag;
	output	[35:0]  result_real;

	wire [35:0] sub_wire0;
	wire [35:0] sub_wire1;
	wire [35:0] result_real = sub_wire0[35:0];
	wire [35:0] result_imag = sub_wire1[35:0];

	cmpl_mul_altmult_complex_78p	cmpl_mul_altmult_complex_78p_component (
				.datab_imag (datab_imag),
				.clock (clock),
				.dataa_imag (dataa_imag),
				.datab_real (datab_real),
				.dataa_real (dataa_real),
				.result_real (sub_wire0),
				.result_imag (sub_wire1));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone III"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: CONSTANT: IMPLEMENTATION_STYLE STRING "AUTO"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Cyclone III"
// Retrieval info: CONSTANT: PIPELINE NUMERIC "6"
// Retrieval info: CONSTANT: REPRESENTATION_A STRING "SIGNED"
// Retrieval info: CONSTANT: REPRESENTATION_B STRING "SIGNED"
// Retrieval info: CONSTANT: WIDTH_A NUMERIC "18"
// Retrieval info: CONSTANT: WIDTH_B NUMERIC "18"
// Retrieval info: CONSTANT: WIDTH_RESULT NUMERIC "36"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: USED_PORT: dataa_imag 0 0 18 0 INPUT NODEFVAL "dataa_imag[17..0]"
// Retrieval info: USED_PORT: dataa_real 0 0 18 0 INPUT NODEFVAL "dataa_real[17..0]"
// Retrieval info: USED_PORT: datab_imag 0 0 18 0 INPUT NODEFVAL "datab_imag[17..0]"
// Retrieval info: USED_PORT: datab_real 0 0 18 0 INPUT NODEFVAL "datab_real[17..0]"
// Retrieval info: USED_PORT: result_imag 0 0 36 0 OUTPUT NODEFVAL "result_imag[35..0]"
// Retrieval info: USED_PORT: result_real 0 0 36 0 OUTPUT NODEFVAL "result_real[35..0]"
// Retrieval info: CONNECT: @datab_real 0 0 18 0 datab_real 0 0 18 0
// Retrieval info: CONNECT: result_imag 0 0 36 0 @result_imag 0 0 36 0
// Retrieval info: CONNECT: result_real 0 0 36 0 @result_real 0 0 36 0
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: @dataa_imag 0 0 18 0 dataa_imag 0 0 18 0
// Retrieval info: CONNECT: @datab_imag 0 0 18 0 datab_imag 0 0 18 0
// Retrieval info: CONNECT: @dataa_real 0 0 18 0 dataa_real 0 0 18 0
// Retrieval info: GEN_FILE: TYPE_NORMAL cmpl_mul_6clk.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL cmpl_mul_6clk.inc FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL cmpl_mul_6clk.cmp FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL cmpl_mul_6clk.bsf FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL cmpl_mul_inst.v FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL cmpl_mul_bb.v FALSE
// Retrieval info: LIB_FILE: altera_mf
